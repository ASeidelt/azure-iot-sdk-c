<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "https://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html xmlns="http://www.w3.org/1999/xhtml">
<head>
<meta http-equiv="Content-Type" content="text/xhtml;charset=UTF-8"/>
<meta http-equiv="X-UA-Compatible" content="IE=9"/>
<meta name="generator" content="Doxygen 1.9.0"/>
<meta name="viewport" content="width=device-width, initial-scale=1"/>
<title>Azure IoT C SDK: Cross Compiling the SDK in a Docker Container</title>
<link href="tabs.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="jquery.js"></script>
<script type="text/javascript" src="dynsections.js"></script>
<link href="search/search.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="search/searchdata.js"></script>
<script type="text/javascript" src="search/search.js"></script>
<link href="style.css" rel="stylesheet" type="text/css" />
</head>
<body>
<div id="top"><!-- do not remove this div, it is closed by doxygen! -->
<div id="titlearea">
<table cellspacing="0" cellpadding="0">
 <tbody>
 <tr style="height: 56px;">
  <td id="projectalign" style="padding-left: 0.5em;">
   <div id="projectname">Azure IoT C SDK
   </div>
  </td>
 </tr>
 </tbody>
</table>
</div>
<!-- end header part -->
<!-- Generated by Doxygen 1.9.0 -->
<script type="text/javascript">
/* @license magnet:?xt=urn:btih:cf05388f2679ee054f2beb29a391d25f4e673ac3&amp;dn=gpl-2.0.txt GPL-v2 */
var searchBox = new SearchBox("searchBox", "search",false,'Search','.html');
/* @license-end */
</script>
<script type="text/javascript" src="menudata.js"></script>
<script type="text/javascript" src="menu.js"></script>
<script type="text/javascript">
/* @license magnet:?xt=urn:btih:cf05388f2679ee054f2beb29a391d25f4e673ac3&amp;dn=gpl-2.0.txt GPL-v2 */
$(function() {
  initMenu('',true,false,'search.php','Search');
  $(document).ready(function() { init_search(); });
});
/* @license-end */</script>
<div id="main-nav"></div>
<!-- window showing the filter options -->
<div id="MSearchSelectWindow"
     onmouseover="return searchBox.OnSearchSelectShow()"
     onmouseout="return searchBox.OnSearchSelectHide()"
     onkeydown="return searchBox.OnSearchSelectKey(event)">
</div>

<!-- iframe showing the search results (closed by default) -->
<div id="MSearchResultsWindow">
<iframe src="javascript:void(0)" frameborder="0" 
        name="MSearchResults" id="MSearchResults">
</iframe>
</div>

</div><!-- top -->
<div class="PageDoc"><div class="header">
  <div class="headertitle">
<div class="title">Cross Compiling the SDK in a Docker Container </div>  </div>
</div><!--header-->
<div class="contents">
<div class="textblock"><h1><a class="anchor" id="autotoc_md85"></a>
Background</h1>
<p>The Microsoft Azure IoT SDK for C is written in C99 standard code. This allows the SDK to be compile and run on a wide variety of platforms. However many of those platforms are incapable of actually compiling the SDK. To address this deficiency one can compile the SDK on a different host, typically a Linux installation, using a cross compile toolchain that will create binaries for one's target platform.</p>
<p>Unfortunately this is not always an easy operation. The IoT SDK has dependencies on some other third party open source projects. These may or may not be available in binary form for your selected platform. </p>
<h1><a class="anchor" id="autotoc_md86"></a>
Purpose of this Document</h1>
<p>This document demonstrates how one can cross compile the SDK inside a Docker container. It consists of a Docker script that builds the SDK for device that is too small to build it on the device. In this instance I am targeting a <a href="http://www.linksprite.com/wiki/index.php5?title=WRTnode">WRTNode</a> device which runs a version of OpenWrt, a commonly found Linux distribution for small devices. </p>
<h1><a class="anchor" id="autotoc_md87"></a>
Prerequisites</h1>
<p>You will need to have a working installation of Docker in order to run the Docker script. However, should you choose not to build the SDK in a Docker container, you will still be able to run the command sequence on a Linux distribution based on Debian such as Ubuntu. </p>
<h1><a class="anchor" id="autotoc_md88"></a>
Process</h1>
<p>The Docker container is based on the latest Ubuntu Docker container. From there we will first install the required Ubuntu packages needed to run the rest of the commands. These are:</p><ul>
<li>git - required to clone the Azure IoT SDK for C</li>
<li>cmake - used to process the CMakeLists.txt files to create makefiles</li>
<li>wget - used to acquire the source of various other components</li>
<li>nano - in case one needs to edit any files in the Docker container</li>
</ul>
<p>Once this is complete, the script will acquire all of the prerequisites. These are:</p><ul>
<li>The toolchain that will build binaries for our target platform. You should substitute the toolchain for your target platform</li>
<li><a href="https://github.com/azure/azure-iot-sdk-c">The IoT SDK source code</a>.</li>
<li><a href="https://www.openssl.org/">OpenSSL</a> - version 1.0.2o used</li>
<li><a href="https://curl.haxx.se/">cURL</a> - version 7.60.0 used</li>
<li><a href="https://en.wikipedia.org/wiki/Util-linux">util-linux</a> for uuid functionality.</li>
</ul>
<p>With all of those in place we can build OpenSSL, cURL, and libuuid. These will be installed into the toolchain as each is built and will be used in the final step when the SDK itself is built.</p>
<h1><a class="anchor" id="autotoc_md89"></a>
Major Tasks</h1>
<p>You will need to identify a suitable toolchain for your target platform and modify the line that downloads this toolchain in your Docker script.</p>
<p>Once this is done, then the environment variable set below will need to be modified to reflect the location and directory names of that toolchain. Once these have been updated then the Docker script should be ready to run.</p>
<h1><a class="anchor" id="autotoc_md90"></a>
The Docker Script</h1>
<p>Here is an example script: </p><div class="fragment"><div class="line"><span class="preprocessor"># Start with the latest version of the Ubuntu Docker container</span></div>
<div class="line">FROM ubuntu:latest</div>
<div class="line"> </div>
<div class="line"><span class="preprocessor">#########################################</span></div>
<div class="line"><span class="preprocessor"># start from home directory</span></div>
<div class="line">RUN cd ~</div>
<div class="line"> </div>
<div class="line"><span class="preprocessor">#########################################</span></div>
<div class="line"><span class="preprocessor"># Run commands that require root authority</span></div>
<div class="line">RUN apt-get update &amp;&amp; apt-get -y upgrade</div>
<div class="line">RUN apt-get install -y cmake git wget nano xz-utils bzip2</div>
<div class="line"> </div>
<div class="line"><span class="preprocessor">#########################################</span></div>
<div class="line"><span class="preprocessor"># Create and switch to new user</span></div>
<div class="line">RUN useradd -d /home/builder -ms /bin/bash -G sudo -p builder builder</div>
<div class="line">USER builder</div>
<div class="line">WORKDIR /home/builder</div>
<div class="line"> </div>
<div class="line"><span class="preprocessor">#########################################</span></div>
<div class="line"><span class="preprocessor"># Download all required files</span></div>
<div class="line">RUN mkdir MIPSBuild</div>
<div class="line">WORKDIR MIPSBuild</div>
<div class="line"> </div>
<div class="line"><span class="preprocessor"># Cross compile toolchain</span></div>
<div class="line">RUN wget https:<span class="comment">//downloads.openwrt.org/releases/21.02.3/targets/ramips/mt7620/openwrt-sdk-21.02.3-ramips-mt7620_gcc-8.4.0_musl.Linux-x86_64.tar.xz</span></div>
<div class="line">RUN tar -xvf openwrt-sdk-21.02.3-ramips-mt7620_gcc-8.4.0_musl.Linux-x86_64.tar.xz</div>
<div class="line"> </div>
<div class="line"><span class="preprocessor"># OpenSSL</span></div>
<div class="line">RUN wget https:<span class="comment">//www.openssl.org/source/openssl-1.0.2o.tar.gz</span></div>
<div class="line">RUN tar -xvf openssl-1.0.2o.tar.gz</div>
<div class="line"> </div>
<div class="line"><span class="preprocessor"># Curl</span></div>
<div class="line">RUN wget http:<span class="comment">//curl.haxx.se/download/curl-7.60.0.tar.gz</span></div>
<div class="line">RUN tar -xvf curl-7.60.0.tar.gz</div>
<div class="line"> </div>
<div class="line"><span class="preprocessor"># Linux utilities for libuuid</span></div>
<div class="line">RUN wget https:<span class="comment">//mirrors.edge.kernel.org/pub/linux/utils/util-linux/v2.32/util-linux-2.32-rc2.tar.gz</span></div>
<div class="line">RUN tar -xvf util-linux-2.32-rc2.tar.gz</div>
<div class="line"> </div>
<div class="line"><span class="preprocessor">#########################################</span></div>
<div class="line"><span class="preprocessor"># Set up environment variables in preperation for the builds to follow</span></div>
<div class="line">ENV WORK_ROOT=/home/builder/MIPSBuild</div>
<div class="line">ENV TOOLCHAIN_MIPS=openwrt-sdk-21.02.3-ramips-mt7620_gcc-8.4.0_musl.Linux-x86_64</div>
<div class="line">ENV TOOLCHAIN_PLATFORM=mipsel-openwrt-linux-musl</div>
<div class="line">ENV STAGING_DIR=${WORK_ROOT}/${TOOLCHAIN_MIPS}/staging_dir</div>
<div class="line">ENV TOOLCHAIN_SYSROOT=${WORK_ROOT}/${TOOLCHAIN_MIPS}/staging_dir/toolchain-mipsel_24kc_gcc-8.4.0_musl</div>
<div class="line">ENV TOOLCHAIN_BIN=${TOOLCHAIN_SYSROOT}/bin</div>
<div class="line">ENV OPENSSL_ROOT_DIR=${WORK_ROOT}/openssl-OpenSSL_1_1_1f</div>
<div class="line">ENV TOOLCHAIN_PREFIX=${WORK_ROOT}/MIPS</div>
<div class="line">ENV AR=${TOOLCHAIN_BIN}/${TOOLCHAIN_PLATFORM}-ar</div>
<div class="line">ENV CC=${TOOLCHAIN_BIN}/${TOOLCHAIN_PLATFORM}-gcc</div>
<div class="line">ENV CXX=${TOOLCHAIN_BIN}/${TOOLCHAIN_PLATFORM}-g++</div>
<div class="line"> </div>
<div class="line"> </div>
<div class="line">ENV LDFLAGS=<span class="stringliteral">&quot;-L${TOOLCHAIN_PREFIX}/lib&quot;</span></div>
<div class="line">ENV LIBS=<span class="stringliteral">&quot;-lssl -lcrypto -ldl -lpthread&quot;</span></div>
<div class="line"> </div>
<div class="line"><span class="preprocessor"># Build OpenSSL</span></div>
<div class="line">WORKDIR openssl-1.0.2o</div>
<div class="line">RUN ./Configure linux-generic32 --prefix=${TOOLCHAIN_PREFIX} --openssldir=${OPENSSL_ROOT_DIR} no-tests shared </div>
<div class="line">RUN make</div>
<div class="line">RUN make install_sw</div>
<div class="line">WORKDIR ..</div>
<div class="line"> </div>
<div class="line"><span class="preprocessor"># Build curl</span></div>
<div class="line">WORKDIR curl-7.60.0</div>
<div class="line">RUN ./configure --with-sysroot=${TOOLCHAIN_SYSROOT} --prefix=${TOOLCHAIN_PREFIX} --target=${TOOLCHAIN_PLATFORM} --with-ssl=${TOOLCHAIN_PREFIX} --with-zlib --host=${TOOLCHAIN_PLATFORM} </div>
<div class="line">RUN make</div>
<div class="line">RUN make install</div>
<div class="line">WORKDIR ..</div>
<div class="line"> </div>
<div class="line"><span class="preprocessor"># Build uuid</span></div>
<div class="line">WORKDIR util-linux-2.32-rc2</div>
<div class="line">RUN ./configure --with-sysroot=${TOOLCHAIN_SYSROOT} --prefix=${TOOLCHAIN_PREFIX} --target=${TOOLCHAIN_PLATFORM} --host=${TOOLCHAIN_PLATFORM} --disable-all-programs  --disable-bash-completion --enable-libuuid</div>
<div class="line">RUN make</div>
<div class="line">RUN make install</div>
<div class="line">WORKDIR ..</div>
<div class="line"> </div>
<div class="line"><span class="preprocessor">#########################################</span></div>
<div class="line"><span class="preprocessor"># Build Azure C SDK</span></div>
<div class="line"> </div>
<div class="line">RUN git clone https:<span class="comment">//github.com/azure/azure-iot-sdk-c.git</span></div>
<div class="line">WORKDIR azure-iot-sdk-c</div>
<div class="line">RUN git submodule update --init</div>
<div class="line">RUN mkdir cmake</div>
<div class="line">WORKDIR cmake</div>
<div class="line"> </div>
<div class="line"><span class="preprocessor"># Create a toolchain file on the fly</span></div>
<div class="line">RUN echo <span class="stringliteral">&quot;SET(CMAKE_SYSTEM_NAME Linux)     # this one is important&quot;</span> &gt; toolchain.cmake</div>
<div class="line">RUN echo <span class="stringliteral">&quot;SET(CMAKE_SYSTEM_VERSION 1)&quot;</span>  &gt;&gt; toolchain.cmake</div>
<div class="line">RUN echo <span class="stringliteral">&quot;SET(CMAKE_SYSROOT ${TOOLCHAIN_SYSROOT})&quot;</span> &gt;&gt; toolchain.cmake</div>
<div class="line">RUN echo <span class="stringliteral">&quot;SET(CMAKE_C_COMPILER ${CC})&quot;</span> &gt;&gt; toolchain.cmake</div>
<div class="line">RUN echo <span class="stringliteral">&quot;SET(CMAKE_CXX_COMPILER ${CXX})&quot;</span> &gt;&gt; toolchain.cmake</div>
<div class="line">RUN echo <span class="stringliteral">&quot;SET(CMAKE_FIND_ROOT_PATH ${WORK_ROOT})&quot;</span> &gt;&gt; toolchain.cmake</div>
<div class="line">RUN echo <span class="stringliteral">&quot;SET(CMAKE_FIND_ROOT_PATH_MODE_PROGRAM NEVER)&quot;</span> &gt;&gt; toolchain.cmake</div>
<div class="line">RUN echo <span class="stringliteral">&quot;SET(CMAKE_FIND_ROOT_PATH_MODE_LIBRARY ONLY)&quot;</span> &gt;&gt; toolchain.cmake</div>
<div class="line">RUN echo <span class="stringliteral">&quot;SET(CMAKE_FIND_ROOT_PATH_MODE_INCLUDE ONLY)&quot;</span> &gt;&gt; toolchain.cmake</div>
<div class="line">RUN echo <span class="stringliteral">&quot;SET(CURL_LIBRARIES ${TOOLCHAIN_PREFIX}/lib/libcurl.so)&quot;</span> &gt;&gt; toolchain.cmake</div>
<div class="line">RUN echo <span class="stringliteral">&quot;SET(ENV{LDFLAGS} -L${TOOLCHAIN_PREFIX}/lib)&quot;</span> &gt;&gt; toolchain.cmake</div>
<div class="line">RUN echo <span class="stringliteral">&quot;SET(OPENSSL_ROOT_DIR ${TOOLCHAIN_PREFIX})&quot;</span> &gt;&gt; toolchain.cmake</div>
<div class="line">RUN echo <span class="stringliteral">&quot;SET(set_trusted_cert_in_samples true CACHE BOOL \&quot;Force use of TrustedCerts option\&quot; FORCE)&quot;</span> &gt;&gt; toolchain.cmake</div>
<div class="line">RUN echo <span class="stringliteral">&quot;include_directories(${TOOLCHAIN_PREFIX}/include)&quot;</span> &gt;&gt; toolchain.cmake</div>
<div class="line"> </div>
<div class="line">RUN cmake -DCMAKE_TOOLCHAIN_FILE=toolchain.cmake ..</div>
<div class="line">RUN cmake --build .</div>
<div class="line">RUN cmake --install . --prefix ${TOOLCHAIN_PREFIX}</div>
<div class="line"> </div>
<div class="line">WORKDIR ../..</div>
<div class="line"> </div>
<div class="line">CMD [<span class="stringliteral">&quot;/bin/bash&quot;</span>]</div>
</div><!-- fragment --><p>To run this script save it to a directory and change to that directory then simply enter: </p><div class="fragment"><div class="line">docker build -t mipsiotbuild:latest . --network=host</div>
</div><!-- fragment --><p> You can replace the value 'mipsiotbuild' with any name that describes your build. In this instance it is building for a MIPS32 processor hence the name. Once the build is complete you will be ready to build your application against the libraries just built.</p>
<p><em>Note:</em> The build of the Azure IoT C SDK uses cmake to generate the makefiles. In order to instruct cmake to perform a cross-compile one uses a cmake toolchain file. This tells cmake where to find the libraries etc. in the toolchain rather than on the host. This file is created on the fly in the above script to reduce dependencies on external files. Alternatively one could create this file outside the script and import into the container.</p>
<h1><a class="anchor" id="autotoc_md91"></a>
Building Your Application</h1>
<p>Once you have successfully built the SDK you are now ready to create your application. You will need to create a directory that contains your source code and a CMakeLists.txt. The application build can use the cmake toolchain file that is already present in the image.</p>
<h2><a class="anchor" id="autotoc_md92"></a>
Sample &lt;tt&gt;CMakeLists.txt&lt;/tt&gt; for an Application</h2>
<p>Here is a simple <code>CMakeLists.txt</code> file that demonstrates how to build an application that uses the libraries built above. This sample, for demonstration purposes uses a copy of the <code>iothub_cross_compile_simple_sample.c</code> sample from the SDK. </p><div class="fragment"><div class="line">cmake_minimum_required (VERSION 3.5)</div>
<div class="line">project(myapp_project)</div>
<div class="line"> </div>
<div class="line"># The demonstration uses C99 but it could just as easily be a C++ application</div>
<div class="line">set (CMAKE_C_FLAGS &quot;--std=c99 ${CMAKE_C_FLAGS}&quot;)</div>
<div class="line"> </div>
<div class="line"># Assume we will use the built in trusted certificates. </div>
<div class="line"># Many embedded devices will need this.</div>
<div class="line">option(use_sample_trusted_cert &quot;Set flag in samples to use SDK&#39;s built-in CA as TrustedCerts&quot; ON)</div>
<div class="line"> </div>
<div class="line">set(iothub_c_files</div>
<div class="line">    iothub_cross_compile_simple_sample.c</div>
<div class="line">)</div>
<div class="line"> </div>
<div class="line"># Conditionally use the SDK trusted certs in the samples (is set to true in cmake toolchain file)</div>
<div class="line">if(${use_sample_trusted_cert})</div>
<div class="line">    add_definitions(-DSET_TRUSTED_CERT_IN_SAMPLES)</div>
<div class="line">    include_directories($ENV{WORK_ROOT}/azure-iot-sdk-c/certs)</div>
<div class="line">    set(iothub_c_files </div>
<div class="line">        ${iothub_c_files} </div>
<div class="line">        $ENV{WORK_ROOT}/azure-iot-sdk-c/certs/certs.c)</div>
<div class="line">endif()</div>
<div class="line"> </div>
<div class="line"># Set up the include and library paths</div>
<div class="line">include_directories(${CMAKE_INSTALL_PREFIX}/include/)</div>
<div class="line">include_directories(${CMAKE_INSTALL_PREFIX}/include/azureiot)</div>
<div class="line">link_directories(/usr/local/lib)</div>
<div class="line">link_directories($ENV{TOOLCHAIN_PREFIX}/lib)</div>
<div class="line"> </div>
<div class="line">add_executable(myapp ${iothub_c_files})</div>
<div class="line"> </div>
<div class="line"># Redundant in this case but shows how to rename your output executable</div>
<div class="line">set_target_properties(myapp PROPERTIES OUTPUT_NAME &quot;myapp&quot;)</div>
<div class="line"> </div>
<div class="line"># If OpenSSL::SSL OR OpenSSL::Crypto are not set then you need to run</div>
<div class="line"># the find package for openssl</div>
<div class="line">if (NOT TARGET OpenSSL::SSL OR NOT TARGET OpenSSL::Crypto OR NOT ${OPENSSL_INCLUDE_DIR})</div>
<div class="line">    find_package(OpenSSL REQUIRED)</div>
<div class="line">endif()</div>
<div class="line">include_directories(${OPENSSL_INCLUDE_DIR})</div>
<div class="line"> </div>
<div class="line"># List the libraries required by the link step</div>
<div class="line">target_link_libraries(myapp iothub_client prov_device_client iothub_client_mqtt_transport prov_auth_client umqtt hsm_security_client utpm dl aziotsharedutil parson pthread curl OpenSSL::SSL OpenSSL::Crypto m )</div>
</div><!-- fragment --> <h2><a class="anchor" id="autotoc_md93"></a>
Using a Separate Docker Script to Build the Application</h2>
<p>Though one could append the application build steps to the Docker script above, this will demonstrate how to use the existing image and build the application in a seperate Docker script. This will keep the original image clean so it may be used for building multiple applications.</p>
<p>This sample script assumes you have your source files and the <code>CMakeLists.txt</code> in a directory called <code>myapp</code>. </p><div class="fragment"><div class="line">FROM mipsiotbuild:latest</div>
<div class="line"> </div>
<div class="line">ENV WORK_ROOT=/home/builder/MIPSBuild</div>
<div class="line">USER builder</div>
<div class="line">WORKDIR /home/builder</div>
<div class="line"> </div>
<div class="line"><span class="preprocessor"># Copy a directory from the host containing the files to build setting ownership at the same time</span></div>
<div class="line">ADD --chown=builder:builder myapp myapp</div>
<div class="line"> </div>
<div class="line"><span class="preprocessor"># Sanity check</span></div>
<div class="line">RUN ls -al myapp</div>
<div class="line"> </div>
<div class="line"><span class="preprocessor"># Switch to application directory</span></div>
<div class="line">WORKDIR myapp</div>
<div class="line"> </div>
<div class="line"><span class="preprocessor"># Create and switch to cmake directory</span></div>
<div class="line">RUN mkdir cmake</div>
<div class="line">WORKDIR cmake</div>
<div class="line"> </div>
<div class="line"><span class="preprocessor"># Generate the makefiles with the same toolchain file and build</span></div>
<div class="line">RUN cmake -DCMAKE_TOOLCHAIN_FILE=${WORK_ROOT}/azure-iot-sdk-c/cmake/toolchain.cmake ..</div>
<div class="line">RUN make</div>
<div class="line"> </div>
<div class="line"><span class="preprocessor"># There should be an executable called myapp</span></div>
<div class="line"><span class="preprocessor">RUN ls -al myapp</span></div>
</div><!-- fragment --><p>Execute this Docker script with: </p><div class="fragment"><div class="line">docker build -t mipsiotapp:latest . --network=host</div>
</div><!-- fragment --> <h1><a class="anchor" id="autotoc_md94"></a>
Copying the Executable from the Docker Container</h1>
<p>Now the applicaton is built the last step is to copy the new executable from your Docker container to your host so that it can be deployed to your target device. An example of how you might do this follows:</p>
<div class="fragment"><div class="line">id =$(docker create mipsiotapp)</div>
<div class="line">docker cp $id:/home/builder/myapp/cmake/myapp ./myapp_exe</div>
<div class="line">docker rm -v $id</div>
</div><!-- fragment --><p> The above steps will create and acquire the Docker container identifier, copy the application to the local directory on the host and then delete the container.</p>
<p><b>Note:</b> Depending upon your device you may need to copy additional binaries from the container in order to add them to your device. For example you device may not have the OpenSSL binaries so you will need to copy libssl.so and libcrypto.so. This could also be true for libuuid and libcurl. All of these libraries will be in the toolchain typically in <code>/usr/local/lib</code>. </p>
<h1><a class="anchor" id="autotoc_md95"></a>
A Complete Example</h1>
<p>You can find three complete examples in <a href="../samples/dockerbuilds">samples</a>. This directory contains Docker scripts to cross compile the SDK for MIPS32, ARM, and for Raspbian and subsequently builds an application. In order to reduce the number of files required, the steps are slightly modified though they perform the same function. To cross compile the SDK for Raspbian, create an application and copy it to your host use the following steps. </p><div class="fragment"><div class="line"># Change directory to your Azure IoT SDK cloned repository root</div>
<div class="line">cd &lt;SDK Root&gt;</div>
<div class="line"># Work in this directory or two copies of the myapp directory will be required</div>
<div class="line">cd samples/dockerbuilds</div>
<div class="line"># Cross compile the SDK</div>
<div class="line">docker build -t rpiiotbuild:latest ./RaspberryPi --network=host</div>
<div class="line"># Build the application against the SDK</div>
<div class="line">docker build -t rpiiotapp:latest . --network=host --file ./RaspberryPi/Dockerfile_adjunct</div>
<div class="line">id=$(docker create rpiiotapp)</div>
<div class="line"># Copy application to home directory</div>
<div class="line">docker cp $id:/home/builder/myapp/cmake/myapp ~/myapp_rpi</div>
<div class="line">docker rm -v $id</div>
</div><!-- fragment --><p> For MIPS32: </p><div class="fragment"><div class="line"># Change directory to your Azure IoT SDK cloned repository root</div>
<div class="line">cd &lt;SDK Root&gt;</div>
<div class="line"># Work in this directory or two copies of the myapp directory will be required</div>
<div class="line">cd samples/dockerbuilds</div>
<div class="line"># Cross compile the SDK</div>
<div class="line">docker build -t mipsiotbuild:latest ./MIPS32 --network=host</div>
<div class="line"># Build the application against the SDK</div>
<div class="line">docker build -t mipsiotapp:latest . --network=host --file ./MIPS32/Dockerfile_adjunct</div>
<div class="line">id=$(docker create mipsiotapp)</div>
<div class="line"># Copy application to home directory</div>
<div class="line">docker cp $id:/home/builder/myapp/cmake/myapp ~/myapp_mips</div>
<div class="line">docker rm -v $id</div>
</div><!-- fragment --><p> And for ARM: </p><div class="fragment"><div class="line"># Change directory to your Azure IoT SDK cloned repository root</div>
<div class="line">cd &lt;SDK Root&gt;</div>
<div class="line"># Work in this directory or two copies of the myapp directory will be required</div>
<div class="line">cd samples/dockerbuilds</div>
<div class="line"># Cross compile the SDK</div>
<div class="line">docker build -t armiotbuild:latest ./ARM --network=host</div>
<div class="line"># Build the application against the SDK</div>
<div class="line">docker build -t armiotapp:latest . --network=host --file ./ARM/Dockerfile_adjunct</div>
<div class="line">id=$(docker create armiotapp)</div>
<div class="line"># Copy application to home directory</div>
<div class="line">docker cp $id:/home/builder/myapp/cmake/myapp ~/myapp_arm</div>
<div class="line">docker rm -v $id</div>
</div><!-- fragment --><p> <b>Note:</b> For these examples to work successfully the image names must be exactly as they are shown in the examples. </p>
<h2><a class="anchor" id="autotoc_md96"></a>
Summing Up</h2>
<p>This document demonstrates how to compile the Azure IoT SDK for C along with all of its dependents and then create and link an application with the libraries and headers. It uses a MIPS32 toolchain for this demonstration but it should be easily adaptable to the toolchain required by the target device. </p>
</div></div><!-- contents -->
</div><!-- PageDoc -->
<!-- start footer part -->
<hr class="footer"/><address class="footer"><small>
Generated by&#160;<a href="https://www.doxygen.org/index.html"><img class="footer" src="doxygen.svg" width="104" height="31" alt="doxygen"/></a> 1.9.0
</small></address>
</body>
</html>
